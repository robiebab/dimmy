'use strict';

const API = require('./API');
const APIError = require('./APIError');
const Util = require('./Util');

const User = require('./AthomCloudAPI/User');
const Homey = require('./AthomCloudAPI/Homey');
const Token = require('./AthomCloudAPI/Token');
const StorageAdapter = require('./AthomCloudAPI/StorageAdapter');
const StorageAdapterBrowser = require('./AthomCloudAPI/StorageAdapterBrowser');
const StorageAdapterMemory = require('./AthomCloudAPI/StorageAdapterMemory');

class AthomCloudAPI extends API {

  static User = User;
  static Homey = Homey;
  static Token = Token;
  static StorageAdapter = StorageAdapter;
  static StorageAdapterBrowser = StorageAdapterBrowser;
  static StorageAdapterMemory = StorageAdapterMemory;

  static SPECIFICATION = require('../assets/specifications/AthomCloudAPI.json');
  static SPECIFICATION_URL = 'https://api.athom.com/specification.json';
  static DEFINITION_CLASSES = {
    User,
    Homey,
  };

  static JSDOC_DESCRIPTION = `
The AthomCloudAPI class can be used to authenticate a user with your client,
and login on that user's Homey.`;

  static JSDOC_EXAMPLE = `
const AthomCloudAPI = require('homey-api/lib/AthomCloudAPI');

// Create an AthomCloudAPI instance
const cloudApi = new {@link AthomCloudAPI AthomCloudAPI}({
  clientId: '5a8d4ca6eb9f7a2c9d6ccf6d',
  clientSecret: 'e3ace394af9f615857ceaa61b053f966ddcfb12a',
  redirectUrl: 'http://localhost',
});

// Check if we're logged in
// If not, redirect the user to the OAuth2 dialog
const loggedIn = await {@link AthomCloudAPI cloudApi}.{@link AthomCloudAPI#isLoggedIn isLoggedIn}();
if (!loggedIn) {
  if ({@link AthomCloudAPI cloudApi}.{@link AthomCloudAPI#hasAuthorizationCode hasAuthorizationCode}()) {
    const token = await  {@link AthomCloudAPI cloudApi}.{@link AthomCloudAPI#authenticateWithAuthorizationCode authenticateWithAuthorizationCode}();
  } else {
    window.location.href =  {@link AthomCloudAPI cloudApi}.{@link AthomCloudAPI#getLoginUrl getLoginUrl}();
    return;
  }
}

// Get the logged in user
const user = await {@link AthomCloudAPI cloudApi}.{@link AthomCloudAPI#getAuthenticatedUser getAuthenticatedUser}();

// Get the first Homey of the logged in user
const homey = await {@link AthomCloudAPI.User user}.{@link AthomCloudAPI.User#getFirstHomey getFirstHomey}();

// Create a session on this Homey
const homeyApi = await {@link AthomCloudAPI.Homey homey}.{@link AthomCloudAPI.Homey#authenticate authenticate}();

// Get all Zones from ManagerZones
const zones = await {@link HomeyAPIV2 homeyApi}.{@link HomeyAPIV2.ManagerZones zones}.{@link HomeyAPIV2.ManagerZones#getZones getZones}();

// Get all Devices from ManagerDevices
const devices = await {@link HomeyAPIV2 homeyApi}.{@link HomeyAPIV2.ManagerDevices devices}.{@link HomeyAPIV2.ManagerDevices#getDevices getDevices}();

// Turn all devices on
for(const {@link HomeyAPIV2.ManagerDevices.Device device} of Object.values(devices)) {
  // Turn device on
  await {@link HomeyAPIV2.ManagerDevices.Device device}.{@link HomeyAPIV2.ManagerDevices.Device#setCapabilityValue setCapabilityValue}({
    capabilityId: 'onoff',
    value: true,
  });
}`;

  static JSDOC_PARAMS = `
@param {string} opts.clientId
@param {string} opts.clientSecret
@param {string} opts.redirectUrl
@param {boolean} [opts.autoRefreshTokens=true]
@param {AthomCloudAPI.Token} [opts.token=null]
@param {AthomCloudAPI.StorageAdapter} [opts.store={@link AthomCloudAPI.StorageAdapterBrowser} or {@link AthomCloudAPI.StorageAdapterMemory}]`;

  constructor({
    clientId,
    clientSecret,
    redirectUrl,
    autoRefreshTokens = true,
    token = null,
    store = Util.isBrowser()
      ? new StorageAdapterBrowser()
      : new StorageAdapterMemory(),
    ...args
  } = {}) {
    super({ ...args });

    this.__clientId = clientId;
    this.__clientSecret = clientSecret;
    this.__redirectUrl = redirectUrl;
    this.__autoRefreshTokens = autoRefreshTokens;

    if (!(store instanceof StorageAdapter)) {
      throw new Error('Invalid `store`. Must extend AthomCloudAPI/StorageAdapter.');
    }
    this.__store = store;

    if (token && !(token instanceof Token)) {
      throw new Error('Invalid `token`. Must extend AthomCloudAPI/Token.');
    }

    this.__token = token;
    this.__user = null;
  }

  /*
   * Session
  */

  /**
   * Checks if the current token is valid, and if the user is logged in.
   * @returns {Promise<boolean>}
   */
  async isLoggedIn() {
    if (this.__token && this.__token.access_token) return true;

    const store = await this.__getStore();

    if (!store.token || !store.token.access_token) return false;

    return true;
  }

  /**
   * Get the current authenticated {@link AthomCloudAPI.User}
   * @param {object} [opts]
   * @param {object} [opts.$cache=true] - Use the cache
   * @returns {Promise<AthomCloudAPI.User>}
   */
  async getAuthenticatedUser({ $cache = true } = {}) {
    if ($cache === true && this.__user instanceof User) {
      return this.__user;
    }

    const properties = await this.call({
      method: 'get',
      path: '/user/me',
    });

    this.__user = new User({
      api: this,
      properties: properties,
    });

    return this.__user;
  }

  async getAuthenticatedUserFromStore({ $cache = true } = {}) {
    if ($cache === true && this.__user instanceof User) {
      return this.__user;
    }

    if ($cache === true && this.__user == null) {
      const store = await this.__getStore();

      if (store.user) {
        this.__user = new User({
          api: this,
          properties: store.user,
        });

        return this.__user;
      }
    }

    const properties = await this.call({
      method: 'get',
      path: '/user/me',
    });

    this.__user = new User({
      api: this,
      properties: properties,
    });

    await this.__setStore({
      user: properties,
    })

    return this.__user;
  }

  /**
   * Checks if the current URL in the browser has a `?code=...` parameter.
   * @returns {boolean}
   */
  hasAuthorizationCode() {
    return !!(Util.isBrowser() && Util.getSearchParameter('code'));
  }

  /**
   * Get a login URL to redirect the user to (MyApp wants access to ...).
   * @param {object} [opts]
   * @param {string} [opts.state] - A state parameter for enhanced security.
   * @param {string[]} [opts.scopes] - An array of scopes. By default, the client's scopes will be used.
   * @returns {string} - The login URL to redirect the user to.
   */
  getLoginUrl({
    state,
    scopes,
  } = {}) {
    if (!this.__redirectUrl) {
      throw new Error('Missing Redirect URL');
    }

    const params = {
      client_id: this.__clientId,
      redirect_uri: this.__redirectUrl,
      response_type: 'code',
    }

    if (typeof state === 'string') {
      params.state = state;
    }

    if (Array.isArray(scopes)) {
      params.scope = scopes.join(',');
    }

    return `${this.baseUrl}/oauth2/authorise?${Util.encodeUrlSearchParams(params)}`;
  }

  async getDelegatedLoginUrl(args = {}) {
    if (args.baseUrl == null) {
      throw new TypeError('baseUrl is required');
    }

    const token = await this.createDelegationToken({
      audience: args.audience,
      meta: args.meta,
    });

    const params = {
      user_token: token,
    }

    if (typeof args.state === 'string') {
      params.state = args.state;
    }

    if (typeof args.resource === 'string') {
      params.resource = args.resource;
    }

    const seperator = args.baseUrl.indexOf('?') >= 0 ? '&' : '?';
    return args.baseUrl + seperator + Util.encodeUrlSearchParams(params);
  }

  /**
   * Logout and delete the local token.
   * @returns {Promise<void>}
   */
  async logout() {
    // Delete Cached User
    this.__user = null;

    // Delete Token from Store
    await this.__resetStore();
    this.__token = null;
  }

  /*
   * Storage
  */

  async __getStore() {
    if (!this.__store) return {};
    return this.__store.get();
  }

  async __setStore(value) {
    if (!this.__store) return;
    const store = await this.__store.get();
    await this.__store.set({
      ...store,
      ...value,
    });
  }

  async __resetStore() {
    if (!this.__store) return;
    await this.__store.set({});
  }

  /*
   * API overloads
  */

  // eslint-disable-next-line no-unused-vars
  async onCallRequestHeaders({ request }) {
    // Try to set the Token from the StorageAdapter
    if (!this.__token) {
      const store = await this.__getStore();
      if (store.token) {
        this.__token = new Token(store.token);
      }
    }

    // Append Access Token to Authorization-header
    if (this.__token && this.__token.access_token) {
      return {
        Authorization: `Bearer ${this.__token.access_token}`,
      };
    }

    return {};
  }

  async onCallResponseNotOK({
    request,
    body,
    statusCode,
    ...props
  }) {
    if (statusCode === 401 && body.error === 'invalid_token') {
      if (this.__autoRefreshTokens && !request.context.isRetryAfterRefresh) {
        this.__debug('Refreshing token...');
        await this.authenticateWithRefreshToken();

        this.__debug('Token refreshed. Retrying call...');
        return this.call({
          ...request,
          context: {
            ...request.context,
            isRetryAfterRefresh: true,
          },
        });
      }
    }

    // { name: 'Invalid value', password: 'Too short' }
    if (typeof body.error_description === 'object' && body.error_description !== null) {
      const message = Object.entries(body.error_description).map(([key, value]) => {
        return `${key}: ${value}`;
      }).join(', ');

      throw new APIError(message, statusCode);
    }

    return super.onCallResponseNotOK({
      body,
      statusCode,
      ...props,
    });
  }

  /*
   * OAuth2
  */

  async authenticateWithClientCredentials() {
    if (!this.__clientId) {
      throw new Error('Missing Client ID');
    }

    if (!this.__clientSecret) {
      throw new Error('Missing Client Secret');
    }

    const params = {
      grant_type: 'client_credentials',
    }

    const response = await Util.fetch(`${this.baseUrl}/oauth2/token`, {
      body: Util.encodeUrlSearchParams(params),
      method: 'post',
      headers: {
        Authorization: `Basic ${Util.base64(`${this.__clientId}:${this.__clientSecret}`)}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    let responseBody;
    try {
      responseBody = await response.json();
    } catch (err) {
      this.__debug(`Invalid response from server (${response.status}): ${response.text()}`);
      throw new APIError(`Invalid response from server: ${response.text()}`, response.status);
    }

    if (!response.ok) {
      throw new APIError(responseBody.error_description || responseBody.error, response.status);
    }

    this.__token = new Token({
      token_type: responseBody.token_type,
      access_token: responseBody.access_token,
      refresh_token: responseBody.refresh_token,
      expires_in: responseBody.expires_in,
      grant_type: 'client_credentials',
    });

    this.__setStore({
      token: this.__token,
    });

    return this.__token;
  }

  /**
   * Authenticate with an authorization code.
   * @param {Object} [opts]
   * @param {String} opts.code - Default to `?code=...` when in a browser.
   * @param {Boolean} [opts.removeCodeFromHistory=true] - Remove `?code=...` from the URL in the address bar.
   * @returns {Promise<AthomCloudAPI.Token>}
   */
  async authenticateWithAuthorizationCode({
    code,
    removeCodeFromHistory = true,
  } = {}) {
    // Auto-fill code from ?code=...
    if (!code && Util.isBrowser()) {
      code = Util.getSearchParameter('code');
    }

    if (!code) {
      throw new Error('Missing Code');
    }

    if (!this.__clientId) {
      throw new Error('Missing Client ID');
    }

    if (!this.__clientSecret) {
      throw new Error('Missing Client Secret');
    }

    const params = {
      grant_type: 'authorization_code',
      code: code,
    }

    const response = await Util.fetch(`${this.baseUrl}/oauth2/token`, {
      body: Util.encodeUrlSearchParams(params),
      method: 'post',
      headers: {
        Authorization: `Basic ${Util.base64(`${this.__clientId}:${this.__clientSecret}`)}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    let responseBody;
    try {
      responseBody = await response.json();
    } catch (err) {
      this.__debug(`Invalid response from server (${response.status}): ${response.text()}`);
      throw new APIError(`Invalid response from server: ${response.text()}`, response.status);
    }

    if (!response.ok) {
      throw new APIError(responseBody.error_description || responseBody.error, response.status);
    }

    this.__token = new Token({
      token_type: responseBody.token_type,
      access_token: responseBody.access_token,
      refresh_token: responseBody.refresh_token,
      expires_in: responseBody.expires_in,
      grant_type: 'authorization_code',
    });

    this.__setStore({
      token: this.__token,
    });

    // Remove ?code=... from URL
    if (Util.isBrowser() && removeCodeFromHistory) {
      const url = new URL(window.location.href);
      url.searchParams.delete('code');

      window.history.pushState(undefined, undefined, url.toString());
    }

    return this.__token;
  }

  async authenticateWithPassword(username, password) {
    if (!username) {
      throw new Error('Missing Username');
    }
    if (!password) {
      throw new Error('Missing Password');
    }

    if (!this.__clientId) {
      throw new Error('Missing Client ID');
    }

    if (!this.__clientSecret) {
      throw new Error('Missing Client Secret');
    }

    const params = {
      grant_type: 'password',
      username: username,
      password: password,
    }

    const response = await Util.fetch(`${this.baseUrl}/oauth2/token`, {
      body: Util.encodeUrlSearchParams(params),
      method: 'post',
      headers: {
        Authorization: `Basic ${Util.base64(`${this.__clientId}:${this.__clientSecret}`)}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    let responseBody;
    try {
      responseBody = await response.json();
    } catch (err) {
      this.__debug(`Invalid response from server (${response.status}): ${response.text()}`);
      throw new APIError(`Invalid response from server: ${response.text()}`, response.status);
    }

    if (!response.ok) {
      throw new APIError(responseBody.error_description || responseBody.error, response.status);
    }

    this.__token = new Token({
      token_type: responseBody.token_type,
      access_token: responseBody.access_token,
      refresh_token: responseBody.refresh_token,
      expires_in: responseBody.expires_in,
      grant_type: 'password',
    });

    this.__setStore({
      token: this.__token,
    });

    return this.__token;
  }

  async authenticateWithExtendedGrantType(grantType, grantParams) {
    if (!grantParams) {
      throw new Error('Missing Params');
    }
    if (!grantType) {
      throw new Error('Missing Grant Type');
    }

    if (!this.__clientId) {
      throw new Error('Missing Client ID');
    }

    if (!this.__clientSecret) {
      throw new Error('Missing Client Secret');
    }

    const params = {
      grant_type: grantType,
      ...grantParams,
    }

    const response = await Util.fetch(`${this.baseUrl}/oauth2/token`, {
      body: Util.encodeUrlSearchParams(params),
      method: 'post',
      headers: {
        Authorization: `Basic ${Util.base64(`${this.__clientId}:${this.__clientSecret}`)}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    let responseBody;
    try {
      responseBody = await response.json();
    } catch (err) {
      this.__debug(`Invalid response from server (${response.status}): ${response.text()}`);
      throw new APIError(`Invalid response from server: ${response.text()}`, response.status);
    }

    if (!response.ok) {
      throw new APIError(responseBody.error_description || responseBody.error, response.status);
    }

    this.__token = new Token({
      token_type: responseBody.token_type,
      access_token: responseBody.access_token,
      refresh_token: responseBody.refresh_token,
      expires_in: responseBody.expires_in,
      grant_type: grantType,
    });

    this.__setStore({
      token: this.__token,
    });

    return this.__token;
  }

  async authenticateWithRefreshToken() {
    if (!this.__refreshTokenPromise) {
      this.__refreshTokenPromise = Promise.resolve().then(async () => {
        if (!this.__token) {
          throw new Error('Missing Token');
        }

        if (!this.__token.refresh_token) {
          throw new Error('Missing Refresh Token');
        }

        const params = {
          grant_type: 'refresh_token',
          refresh_token: this.__token.refresh_token,
        }

        const response = await Util.fetch(`${this.baseUrl}/oauth2/token`, {
          body: Util.encodeUrlSearchParams(params),
          method: 'post',
          headers: {
            Authorization: `Basic ${Util.base64(`${this.__clientId}:${this.__clientSecret}`)}`,
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        });

        let responseBody;
        try {
          responseBody = await response.json();
        } catch (err) {
          this.__debug(`Invalid response from server (${response.status}): ${response.text()}`);
          throw new APIError(`Invalid response from server: ${response.text()}`, response.status);
        }

        if (!response.ok) {
          throw new APIError(responseBody.error_description || responseBody.error, response.status);
        }

        this.__token = new Token({
          token_type: responseBody.token_type,
          access_token: responseBody.access_token,
          refresh_token: responseBody.refresh_token,
          expires_in: responseBody.expires_in,
          grant_type: this.__token.grant_type,
        });

        this.__setStore({
          token: this.__token,
        });

        return this.__token;
      });

      this.__refreshTokenPromise
        .catch(() => { })
        .finally(() => {
          this.__refreshTokenPromise = null;
        });
    } else {
      this.__debug('Already refreshing token reusing promise.');
    }

    return this.__refreshTokenPromise;
  }

  /**
   * Update the currently authenticated user.
   *
   * @private
   * @param {Object} [opts]
   * @param {String} [opts.firstname]
   * @param {String} [opts.lastname]
   * @param {String} [opts.email]
   * @returns {Promise<AthomCloudAPI.User>}
   */
  async updateUserMe({
    firstname,
    lastname,
    email,
  }) {
    const me = await this.getAuthenticatedUser();
    return this.updateUser({
      id: me._id,
      user: {
        firstname,
        lastname,
        email,
      },
    });
  }

  /**
   * Update the currently authenticated user's avatar.
   *
   * @private
   * @param {Buffer} imageBuffer Buffer of the new avatar
   * @param {"jpg"|"jpeg"|"png"|"gif"} imageType Type of the new avatar
   * @returns {Promise<Object>}
   */
  async updateUserMeAvatar(imageBuffer, imageType) {
    if (!Buffer.isBuffer(imageBuffer)) {
      throw new Error('Invalid Image. Expected Buffer.');
    }

    if (!imageType) {
      throw new Error('Missing Image Type');
    }

    if (!['jpg', 'png', 'gif'].includes(imageType)) {
      throw new Error(`Invalid Image Type: ${imageType}`);
    }

    if (imageType === 'jpg') {
      imageType = 'jpeg';
    }

    const me = await this.getAuthenticatedUser();
    const body = Buffer.concat([
      Buffer.from(`--__X_HOMEY_BOUNDARY__\r\nContent-Disposition: form-data; name="avatar"; filename="avatar"\r\nContent-Type: image/${imageType}\r\n\r\n`),
      Buffer.from(imageBuffer),
      Buffer.from('\r\n--__X_HOMEY_BOUNDARY__--\r\n'),
    ]);

    return this.call({
      method: 'POST',
      path: `/user/${me._id}/avatar`,
      headers: {
        'Content-Type': 'multipart/form-data; boundary="__X_HOMEY_BOUNDARY__"',
        'Content-Length': body.length,
      },
      body,
      bodyJSON: false,
    });
  }

}

module.exports = AthomCloudAPI;
